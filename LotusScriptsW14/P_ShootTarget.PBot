const ui = Java.type('haven.purus.pbot.PBotAPI').ui(); 
const PBot = Java.type("haven.purus.pbot.PBotAPI");
const PBotUtils = Java.type('haven.purus.pbot.PBotUtils');
const PBotGobAPI = Java.type('haven.purus.pbot.PBotGobAPI');
const PBotWindowAPI = Java.type('haven.purus.pbot.PBotWindowAPI');




const VERSIONNAME = "1.0"
const WINDOWNAME = "ShootTarget";



let stop;
const cooldownTime = 2000;
const rangeofshot = 100;
const radius = 150;
windowWidth = 170;
windowHeight = 140;
const window = PBotUtils.PBotWindow(ui, WINDOWNAME, windowWidth, windowHeight, ScriptID);
const infoRadius = window.addLabel("Radius: " + radius, 10, 10);
const statusLbl = window.addLabel("Status: Idle", 10, 20);
const progressBarLbl = window.addLabel("Progress: [----------]", 10, 30);
const cooldownLbl = window.addLabel("Cooldown: 0", 10, 70);
window.addLabel("_______________", 20, 120);
const cboxArrowPick = window.addCheckbox("checkboxPickArrows", "Collect Arrows", false, 10, 110);

//Adding default values
cboxArrowPick.setValue(true);

const updateWindow = (status, progress) => {
    statusLbl.settext("Status: " + status);
    progressBarLbl.settext("Progress: " + progress);
}
function convertCooldownToProgress(cooldownTimer) {
  const progress = Math.min(1, cooldownTimer / cooldownTime);
  return progress;
}


function getProgressBar(progress) {
    const numDots = Math.floor(progress * 10);
    const progressBar = "[" + ">".repeat(numDots) + "-".repeat(10 - numDots) + "]";
    return progressBar;
}




const main = () => {
    stop = false;
    let target = null;
    let targetDistance = null;

    PBotUtils.sysMsg(ui, "Bot Start", 127, 255, 0);
    const main_startTime = Date.now();
    let shootTimer_Start = 0; // Declare the shoot timer variable

    do {
        updateWindow("Starting Loop", getProgressBar(0));
        let loop_startTime = Date.now();
        let AnimalGob = searchForAnimals(radius);

        if (AnimalGob == null) {
            if (cboxArrowPick.getValue()) {
                let gob = searchForArrows(radius);
                if (gob == null) {
                    PBotUtils.sysMsg(ui, "Found no Animals", 220, 20, 60);
                    PBotUtils.sysMsg(ui, "Found no Arrows", 255, 0, 0);
                    stop = true;
                } else {
                    updateWindow("Picking Up Arrow", getProgressBar(0.5));
                    gob.doClick(3, 0);    
                    while (!stop && !window.closed() && PBotGobAPI.player(ui).isMoving()){
                        updateWindow("Waiting for player to stop moving", getProgressBar(0.75));
                        PBotUtils.sleep(500);
                        PBotUtils.sysMsg(ui, "Waiting for player to pick up arrow", 175,238,238);
                    }
                    PBotUtils.sleep(50);
                }
            }
        } else {
            let timelapsed = Date.now() - shootTimer_Start;
            const progress = convertCooldownToProgress(timelapsed);
            updateWindow("Cooldown Timer:", getProgressBar(progress));

            if (timelapsed >= cooldownTime) {
                let distance = distanceToGob(AnimalGob);
                if (distance < rangeofshot) {
                    // Perform shooting logic here
                    updateWindow("Shooting:", getProgressBar(progress));
                    PBotUtils.sysMsg(ui, "Shooting: " + AnimalGob.getResname(), 255,105,180);
                    PBotUtils.sleep(1000);
                    shootTimer_Start = Date.now();
                } else {
                    PBotUtils.sysMsg(ui, "To far away from target: " + distance + "  max distance: " + rangeofshot, 255,20,147);
                    updateWindow("To far away!", getProgressBar(0));
                }
            }


            if (target != null) {
                target.destroy();
            }

            if (targetDistance != null) {
                targetDistance.destroy();
            }

            target = window.addLabel(AnimalGob.getResname().toString(), 10, 50);
            targetDistance = window.addLabel("Distance: " + Math.floor(distanceToGob(AnimalGob)), 10, 60);        
            PBotUtils.sleep(50);            
        }

        let func_startTime = Date.now();
        let func_timeSpentWaiting = 0;
        PBotUtils.sleep(50);
    } while (!stop && !window.closed());

    window.closeWindow();
    PBotUtils.sysMsg(ui, "Bot finished! (closing window)", 255, 165, 0);
};
main();


function searchForAnimals(radius) {
    let animalGobs = [
        'gfx/terobjs/archerytarget',
        'gfx/kritter/boar/boar',
        'gfx/kritter/wolverine/wolverine',
        'gfx/kritter/otter/otter',
        'gfx/kritter/cattle/cattle',
        'gfx/kritter/fox/fox',
        'gfx/kritter/reddeer/reddeer',
        'gfx/kritter/beaver/beaver',
        'gfx/kritter/badger/badger',
        'gfx/kritter/sheep/sheep',
    ];
    for (var i = 0; i < animalGobs.length; i++) {
        let gob = PBotGobAPI.findGobByNames(ui, parseFloat(radius), animalGobs[i]);
        if (gob) {
            return gob;
        }
    }
}
function searchForArrows(radius) {
    let gob = PBotGobAPI.findGobByNames(ui, parseFloat(radius), 'gfx/terobjs/items/arrow');
    if (gob) {
        return gob;
    }
}


function distanceToGob(gob) {
    const gobPos = gob.getRcCoords().floor();
    const playerPos = PBotGobAPI.player(ui).getRcCoords().floor();
    const distanceX = gobPos.x - playerPos.x;
    const distanceY = gobPos.y - playerPos.y;
    const total = pythagorean(distanceX, distanceY);
    return total;
}
function pythagorean(sideA, sideB) {
    return Math.sqrt(Math.pow(sideA, 2) + Math.pow(sideB, 2));
}
function checkboxPickArrows() { }