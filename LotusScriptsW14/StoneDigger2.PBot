const ui = Java.type('haven.purus.pbot.PBotAPI').ui();
const PBotUtils = Java.type('haven.purus.pbot.PBotUtils');
const PBotCharacterAPI = Java.type('haven.purus.pbot.PBotCharacterAPI');
const PBotGobAPI = Java.type('haven.purus.pbot.PBotGobAPI');


////////////////
	stone = "Basalt";
	let stockpileName = 'gfx/terobjs/stockpile-stone';
	let stoneTiles = [];
	let stockPiles = [];	
////////////////
windowWidth = 100;
windowHeight = 200;
const window = PBotUtils.PBotWindow(ui, "StateMan 2", windowWidth, windowHeight, ScriptID);
const btnStart = window.addButton("btnStartClick", "Start", 70, windowWidth-35, 70);
const btnStartClick = () => {
	stop = false;
	btnStart.hide();
	main();
	btnStart.show();
}
///////////////
const tick = 500;
let stop;
const shouldStop = () => {
	return stop || window.closed();
};
const main = () => {
	if (!stop && !window.closed()) {
		timeStartOfBot = Date.now();
		const context = new Context();
		let stop = false;
		let stoneStored = 0
		let stoneInvAmount = PBotUtils.playerInventory(ui).getInventoryItemsByNames(stone).size();

		while (!shouldStop()) {
			context.update();
		}
	}
	PBotUtils.sysMsg(ui, "done!");
};

function waitForIdle() {
  const maxWaitTICKs = 4;
  const TICK = 200;
  let idleCounter = maxWaitTICKs;
  while (idleCounter >= 0) {
    if (PBotUtils.getHourglass(ui) == -1)
      idleCounter--;
    else {
      idleCounter = maxWaitTICKs;
    }
    PBotUtils.sleep(TICK);
  }
}
function dig (tiles){
	PBotUtils.pfLeftClick(ui, tiles[0].x, tiles[0].y);
	PBotCharacterAPI.doAct(ui, "dig");
	PBotUtils.mapClick(ui, tiles[0].x, tiles[0].y, 1, 0);
	PBotCharacterAPI.cancelAct(ui);
	if(!PBotUtils.getHourglass(ui) >= 0) {
		PBotUtils.waitForHourglass(ui);
	}
}

class Context {
  constructor() {
    this.currentState = new ProcessingState(this);
    // add window labels
    this.statusLbl = window.addLabel("Initializing...", 10, 10);
    this.progressLbl = window.addLabel("", 10, 25);
    this.estLbl = window.addLabel("Estimated time:", 10, 40);
    this.timeLbl = window.addLabel("00", 10, 60);
    this.devider = window.addLabel("_______________", 25, 65);
  }
  
  setState(state) {
  	// perform any cleanup tasks for the processing state
  	PBotUtils.sysMsg(ui, "exit " + this.currentState.constructor.name + "! (waiting " + 25 + "ms)" );
    PBotUtils.sleep(25);
    this.currentState.exit();
    this.currentState = state;
    this.currentState.enter();

  }
  
  update() {
  	this.elapsedTime = Date.now() - timeStartOfBot;
  	this.estimatedTime = this.elapsedTime * 2;
    this.currentState.update();
    // update window labels
    this.statusLbl.settext("Current state:" + this.currentState.constructor.name);
    this.progressLbl.settext("Progress: " + this.elapsedTime);
    this.timeLbl.settext(this.formatTime(this.elapsedTime) + " / " + this.formatTime(this.estimatedTime));
  }
  
  formatTime(milliseconds) {
    // helper function to format time in mm:ss format
    const seconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(seconds / 60);
    const secondsRemainder = seconds % 60;
    return minutes.toString().padStart(2, "0") + ":" + secondsRemainder.toString().padStart(2, "0");
  }
}
class State {
  constructor(context) {
    this.context = context;
  }

  enter() {
  }
  
  exit() { }
  
  update() {}
}
class ProcessingState extends State {

  update() {
    // perform any logic needed while in the processing state
    // transition to the idle state when processing is complete
		const playerSpeed = PBotCharacterAPI.getSpeed(ui);
		const playerIsMoving = PBotGobAPI.player(ui).isMoving();
		if (playerIsMoving) {
			if (playerSpeed >= 3) {
				this.context.setState(new RunningState(this.context));
				PBotUtils.sysMsg(ui, "Setting state to running" );
			}
			else{
				PBotUtils.sysMsg(ui, "Setting state to walking (" + playerSpeed + ")" );
		  		this.context.setState(new WalkingState(this.context));
			}
		}

		if (stoneTiles.length <= 0 || stockPiles.length <= 0){
    		PBotUtils.sysMsg(ui, "Starting Setup: ");
    		this.context.setState(new SetupState(this.context));
    	} else {
    	}

    	if (PBotUtils.playerInventory(ui).freeSlotsInv() > 5 && stoneTiles.length > 0){
    		this.context.setState(new DiggingState(this.context));
    	} else {
    		PBotUtils.sysMsg(ui, "Failed to start digging");
    		PBotUtils.sysMsg(ui, "Failed; Free inventory space: " + PBotUtils.playerInventory(ui).freeSlotsInv());
    		PBotUtils.sysMsg(ui, "Failed; stoneTiles.length: " + stoneTiles.length);
    	}

    	if(!PBotUtils.getHourglass(ui) >= 0 && !playerIsMoving && stoneTiles.length > 0){
    		this.context.setState(new IdleState(this.context));
    	}
		
		
  }
}
class SetupState extends State {
	enter() {
			PBotUtils.sysMsg(ui, "Starting Setup State");
	}

	exit() {
	// perform any cleanup tasks for the idle state
	}

	update() {
		if (stoneTiles.length === 0){
			stoneTiles = this.selectTiles();
		} else {
			PBotUtils.sysMsg(ui, "stone tiles already exists: " + stoneTiles.length);
		}

		if (stockPiles.length === 0){
			stockPiles = this.selectStockpiles();
		} else {
			PBotUtils.sysMsg(ui, "stockpiles already exists: " + stockPiles.length);
		}
		if (stoneTiles.length > 0 && stockPiles.length > 0){
			this.context.setState(new ProcessingState(this.context));
		}
	}

	selectTiles(){
		let stoneTiles = [];
		PBotUtils.sysMsg(ui, "Select area to dig stones from!");
		PBotUtils.selectArea(ui);
		const aCoordDig = PBotUtils.getSelectedAreaA();
		const bCoordDig = PBotUtils.getSelectedAreaB();
		const maxX = Math.max(aCoordDig.x, bCoordDig.x);
		const minX = Math.min(aCoordDig.x, bCoordDig.x);
		const maxY = Math.max(aCoordDig.y, bCoordDig.y);
		const minY = Math.min(aCoordDig.y, bCoordDig.y);
		console.log(maxX + " ja " + minX + " JA " + maxY + " ja " + minY);
		for(let i=minY; i<maxY; i += 11) {
			for(let j=minX; j<maxX; j += 11) {
				if(PBotUtils.tileResnameAt(ui, j, i) === "gfx/tiles/mountain") {
					stoneTiles.push({x: j, y: i});
				}
			}
		}
		return stoneTiles;
	}
	selectStockpiles(){
	let stockpiles = [];
	PBotUtils.sysMsg(ui, "Select area with stockpiles!");
	PBotUtils.selectArea(ui);
	const gobs = PBotUtils.gobsInArea(ui, PBotUtils.getSelectedAreaA(), PBotUtils.getSelectedAreaB());
	for(let i=0; i<gobs.size(); i++) {
		if(gobs[i].getResname() === stockpileName)
			stockpiles.push(gobs[i]);
	}
	return stockpiles;
}
}
class IdleState extends State {
  enter() {
    // perform any setup tasks for the idle state
  }
  
  exit() {
    // perform any cleanup tasks for the idle state
  }
  
  update() {
    // perform any logic needed while in the idle state
    // transition to the walking state when ready to start processing again
    this.context.setState(new ProcessingState(this.context));
    waitForIdle();
  }
}
class WalkingState extends State {
  enter() {
    // perform any setup tasks for the walking state
  }
  
  exit() {
    // perform any cleanup tasks for the walking state
  }
  update() {
	const playerIsMoving = PBotGobAPI.player(ui).isMoving();
	const playerSpeed = PBotCharacterAPI.getSpeed(ui);
    if (playerIsMoving && playerSpeed < 3)  {
    	//Keep Walking
    } else 
    	this.context.setState(new ProcessingState(this.context));
  }
}
class RunningState extends State {
  enter() {
    // perform any setup tasks for the running state
  }
  
  exit() {
    // perform any cleanup tasks for the running state
  }
  
  update() {
	const playerIsMoving = PBotGobAPI.player(ui).isMoving();
	const playerSpeed = PBotCharacterAPI.getSpeed(ui);
    if (playerIsMoving && playerSpeed >= 3)  {
    	//Keep Running
    } else 
    	this.context.setState(new ProcessingState(this.context));
  }
}
class PFState extends State {
	enter() {
		PBotUtils.sysMsg(ui, "Starting PFState");
	}

	exit() {
		// perform any cleanup tasks for the running state
	}

	update() {
		const playerIsMoving = PBotGobAPI.player(ui).isMoving();
		const playerSpeed = PBotCharacterAPI.getSpeed(ui);
		if (playerIsMoving)  {
			//Keep Running
		} else 
			this.context.setState(new ProcessingState(this.context));
	}
}
class DiggingState extends State {
	enter() {
		    PBotUtils.sysMsg(ui, "Starting Digging State");
		    let freeSpace = PBotUtils.playerInventory(ui).freeSlotsInv();
	}

	exit() {
	// perform any cleanup tasks for the running state
	}

	update() {
		PBotUtils.sysMsg(ui, "DiggingState Update");
		freeSpace = PBotUtils.playerInventory(ui).freeSlotsInv();
		if(freeSpace > 1 && !playerIsMoving) {
			this.dig(stoneTiles);
			PBotCharacterAPI.doAct(ui, "dig");
			PBotUtils.mapClick(ui, tiles[0].x, tiles[0].y, 1, 0);
			PBotCharacterAPI.cancelAct(ui);
		} else {
			PBotUtils.sysMsg(ui, "DiggingState Update" + !playerIsMoving);
			this.context.setState(new ProcessingState(this.context));
		}
	}
	dig (tiles){

		PBotUtils.pfLeftClick(ui, tiles[0].x, tiles[0].y);
		PBotCharacterAPI.doAct(ui, "dig");
		PBotUtils.mapClick(ui, tiles[0].x, tiles[0].y, 1, 0);
		PBotCharacterAPI.cancelAct(ui);
		if(!PBotUtils.getHourglass(ui) >= 0) {
			PBotUtils.waitForHourglass(ui);
		}
	}
}
class StoringState extends State {
	enter() {
		    PBotUtils.sysMsg(ui, "Starting Storing State");
		    if(stoneStockpiles.length == 0) {
				stop = true;
				PBotUtils.sysMsg(ui, "Ran out of free stockpiles!");
			}
	}

	exit() {
	// perform any cleanup tasks for the running state
	}

	update() {
		PBotUtils.sysMsg(ui, "StoringState Update");
		freeSpace = PBotUtils.playerInventory(ui).freeSlotsInv();
		if(freeSpace > 0 && !playerIsMoving) {
			this.store();
		} else {
			this.context.setState(new ProcessingState(this.context));
		}
	}
	store(){
		PBotUtils.pfRightClick(ui, stoneStockpiles[0], 0);

		PBotWindowAPI.waitForWindow(ui, "Stockpile");

		if (PBotWindowAPI.getWindow(ui, "Stockpile")){
			stoneInvAmount = PBotUtils.playerInventory(ui).getInventoryItemsByNames(stone).size();
			const slots = PBotWindowAPI.getStockpileTotalCapacity(ui);
			const used = PBotWindowAPI.getStockpileUsedCapacity(ui);
			const count = Math.min(stoneInvAmount, slots-used);

			PBotWindowAPI.putItemFromInventoryToStockpile(ui, count);
			PBotUtils.sysMsg(ui, "Tried to add: " + count + " Into a stockpile containing: " + used + "/" + slots);
			PBotUtils.sleep(200);

			stoneStored += count;
			stoneInvAmount -= count;
			stoneStoredLabel.destroy();
			stoneStoredLabel = window.addLabel("stone stored: " + stoneStored, 10, 10);
			if(count + used === slots){
				PBotUtils.sysMsg(ui, "Stockpile Full, starting with a new one ..");
				stoneStockpiles.shift();
			}
		} else {
			PBotUtils.sysMsg(ui, "Could not find stockpile window!");
		}
	}
}




